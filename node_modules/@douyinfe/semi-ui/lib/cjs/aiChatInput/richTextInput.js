"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = require("@tiptap/react");
var _react2 = _interopRequireWildcard(require("react"));
var _extensionDocument = _interopRequireDefault(require("@tiptap/extension-document"));
var _extensionText = _interopRequireDefault(require("@tiptap/extension-text"));
var _extensions = require("@tiptap/extensions");
var _extensionParagraph = _interopRequireDefault(require("@tiptap/extension-paragraph"));
var _extensionHardBreak = _interopRequireDefault(require("@tiptap/extension-hard-break"));
var _inputSlot = _interopRequireDefault(require("./extension/inputSlot"));
var _selectSlot = _interopRequireDefault(require("./extension/selectSlot"));
var _skillSlot = _interopRequireDefault(require("./extension/skillSlot"));
var _constants = require("@douyinfe/semi-foundation/lib/cjs/aiChatInput/constants");
var _plugins = require("./extension/plugins");
var _statusExtension = _interopRequireDefault(require("./extension/statusExtension"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const PREFIX = _constants.cssClasses.PREFIX;
var _default = props => {
  const {
    setEditor,
    onKeyDown,
    onChange,
    placeholder,
    extensions = [],
    defaultContent,
    onPaste,
    innerRef,
    handleKeyDown,
    onFocus,
    onBlur,
    handleCreate
  } = props;
  const isComposing = (0, _react2.useRef)(false);
  const handleCompositionStart = (0, _react2.useCallback)(view => {
    isComposing.current = true;
  }, []);
  const handleCompositionEnd = (0, _react2.useCallback)(view => {
    isComposing.current = false;
    (0, _plugins.handleCompositionEndLogic)(view);
  }, []);
  const handleTextInput = (0, _react2.useCallback)((view, from, to, text) => {
    if (isComposing.current) {
      return false;
    }
    return (0, _plugins.handleTextInputLogic)(view, from, to, text);
  }, []);
  const allExtensions = (0, _react2.useMemo)(() => {
    return [_extensionDocument.default, _extensionParagraph.default, _extensionText.default, _extensions.UndoRedo, _extensionHardBreak.default, _inputSlot.default, _selectSlot.default, _skillSlot.default, _extensions.Placeholder.configure({
      placeholder: placeholder
    }), _statusExtension.default, ...extensions];
  }, [extensions, placeholder]);
  const editorProps = (0, _react2.useMemo)(() => {
    return {
      handleKeyDown: handleKeyDown,
      handlePaste: _plugins.handlePasteLogic,
      handleTextInput,
      handleDOMEvents: {
        compositionstart: handleCompositionStart,
        compositionend: handleCompositionEnd
      }
    };
  }, [handleKeyDown, handleTextInput, handleCompositionStart, handleCompositionEnd]);
  // const onSelectionUpdate = useCallback(({ editor }) => {
  //     // For debug
  //     const fromPos = editor.state.selection.from;
  //     const { $from } = editor.state.selection;
  //     console.log('光标/选区位置', fromPos, editor.state.selection, editor.state.doc);
  //     // console.log('before', $from.nodeBefore, $from.nodeAfter);
  // }, []);
  const onCreate = (0, _react2.useCallback)(_ref => {
    let {
      editor
    } = _ref;
    const {
      state,
      view
    } = editor;
    const tr = (0, _plugins.handleZeroWidthCharLogic)(state);
    if (tr) {
      // 一次性触发，避免多次触发导致 appendTransaction 被多次调用
      view.dispatch(tr);
    }
    handleCreate();
  }, [handleCreate]);
  const onUpdate = (0, _react2.useCallback)(_ref2 => {
    let {
      editor
    } = _ref2;
    // The content has changed.
    const content = editor.getText();
    onChange(content);
  }, [onChange]);
  const handlePaste = (0, _react2.useCallback)(e => {
    var _a;
    // To support file paste
    const items = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items;
    let files = [];
    if (items) {
      for (const it of items) {
        const file = it.getAsFile();
        file && files.push(it.getAsFile());
      }
    }
    if (files.length) {
      onPaste === null || onPaste === void 0 ? void 0 : onPaste(files);
    }
  }, [onPaste]);
  const editor = (0, _react.useEditor)({
    extensions: allExtensions,
    content: defaultContent !== null && defaultContent !== void 0 ? defaultContent : ``,
    editorProps: editorProps,
    // onSelectionUpdate,
    onCreate,
    onUpdate,
    onPaste: handlePaste
  });
  (0, _react2.useEffect)(() => {
    setEditor(editor);
  }, [editor, setEditor]);
  return /*#__PURE__*/_react2.default.createElement(_react2.default.Fragment, null, /*#__PURE__*/_react2.default.createElement(_react.EditorContent, {
    editor: editor,
    onKeyDown: onKeyDown,
    onFocus: onFocus,
    onBlur: onBlur,
    ref: innerRef,
    className: `${PREFIX}-editor-content`
  }));
};
exports.default = _default;